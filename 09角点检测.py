import numpy as np
import cv2 as cv

if __name__ == '__main__':

    img = cv.imread('test.png')
    gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)

    # Harris角点检测---具有旋转不变形
    # 理论推导实在是又臭又长
    # 要求图像输入格式为float32，blockSize指定检测区域的大小
    # ksize定义的Sobel求导中使用的窗口大小，k取值【0.04,0.06】
    cv.cornerHarris(src=gray_img, blockSize=2, ksize=3, k=0.04)

    """
    # SIFT 尺度不变特征变换 角点检测
    1.尺度空间机制检测
    （1）高斯滤波---会生成多种相同尺寸的不同迷糊程度的图像
    （2）图像金子塔---保证每张模糊的图像都进金字塔（图像大小变化）
    （3）构造高斯差分金字塔（DOg）空间---
            差分：相同尺寸的模糊程度不同的图像和相邻的图像进行相减，
                 得到  数量-1  张图像的差分结果
    （4）极值检测---在差分结果中观察特征点（两者相减），
            什么样的才可以称之为特征点，差距较大的，就认为是差分点
            当前窗口（假设3×3）的点与两部分区域进行比较：
                @1.当前层排除自身外的周围8个点
                @2.其上下两层（每层9个点）进行比较，一共26个点（离散点）
            但是最上面层与最下面的层是比较不了的

    2.关键点搜索与定位---对离散空间进行插值，找到精确特征点
        对 离散值 进行曲线拟合计算其极值点（若干维度！），与泰勒级数有关
        从而实现关键点的精确定位

    3.特征方向赋值
    （1）关键点梯度求解
    （2）利用关键点邻域所含有点的，当做极值点方向

    4.关键点描述---对关键带你周围像素进行方向统计、高斯加权，生成
        使用直方图统计领域内像素的梯度和方向  
        分为八个主方向区域（“米”）0-45,45-90,90-135,135-180.....
        为了保证特征矢量旋转不变的特性，以特征为中心，在附近邻域内将坐标轴
        旋转a°，即将坐标轴旋转为特征点的主方向（8个方向，“米”）
        在图像中分成若干个X乘X（假设4*4）大小的区域，每个区域分别统计，每个区域有8个方向
        所以说会生成共计4*4*8=128维向量
    """

    sift = cv.SIFT_create()
    # 检测并生成关键点
    keypoint = sift.detect(gray_img, None)
    # 绘制关键点
    img = cv.drawKeypoints(image=gray_img, keypoints=keypoint, outImage=img)

    cv.imshow()
