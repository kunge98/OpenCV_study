import cv2 as cv
import numpy as np


if __name__ == '__main__':

    img = cv.imread('test.png')

    # 三、边缘检测
    # Sobel算子，理论推导
    # ddepth图像的深度，ksize代表算子的大小
    # 算子和原图进行卷积运算后会出现负值
    # 算子和原图进行卷积运算后会出现绝对值大于255的情况
    # 设置ddepth=cv.CV_64F后会保留负数的梯度，范围保持在[-255,255]
    # 使用cv2.convertScaleAbs()函数把负梯度变正，就得到边缘信息了
    cv.Sobel(src=img, ddepth=cv.CV_64F, dx=1, dy=0, ksize=(3, 3))

    # scharr算子,捕捉到更丰富的梯度信息
    # 原理与sobel一样，sobel算子结构较小，计算精度不高，所以又找出一个精度高的scharr算子
    cv.Scharr(src=img, ddepth=cv.CV_64F, dx=1, dy=0)

    # laplacian算子
    # 二阶导数算子，具有旋转不变性，可以满足不同方向的图像边缘检测
    # 二阶运算更能提取边缘！
    # 也说明二阶运算对原图的边缘响应更敏感！
    # 也说明二阶运算提取图像边缘效果比一阶运算效果好！
    cv.Laplacian(src=img, ddepth=cv.CV_64F)

    # Canny边缘检测算子几乎是最优秀的边缘检测算子!

    # Canny边缘检测算子优劣评判的三条标准：
    # 1.较高的检测率。边缘检测算子应该只对边缘进行响应，检测算子不漏检任何边缘，也不应该将非边缘标记为边缘。
    # 2.精确定位。检测到的边缘与实际边缘之间的距离要尽可能的小。
    # 3.明确的响应。对每一条边缘只有一次响应，只得到一个点。

    # Canny边缘检测的创新点：在一阶微分算子的基础上，增加了非最大值抑制和双阈值两项改进
    # 利用非极大值抑制不仅可以有效地抑制多响应边缘，而且还可以提高边缘的定位精度；
    # 利用双阈值可以有效减少边缘的漏检率

    # Canny边缘检测步骤
    # 1.使用高斯滤波器去噪。噪声会影响边缘检测的准确性，(不一定非要用高斯滤波)
    # 当高斯核的尺寸一定，那么数值越大的核，对噪声的平滑效果就越小，就达不到去除伪边缘的效果。
    # 当高斯核的数值大致相当，那么核的尺寸越大，对噪声的平滑效果就越大， 但同时也模糊了一些弱的边缘，容易弱边缘检测不到。
    # 2.计算梯度大小和方向（上下左右一共8个方向）
    # 3.非极大值抑制。（线性插值法）
    # 判断当前像素点是否是周围像素点中具有相同梯度方向的最大值，是，就保留，不是，就抑制
    # 通过NMS非极大值抑制可以将边缘信息变瘦
    # 4.双阈值检测。使用双阈值法确定最终的边缘信息
    # 经过非极大值抑制还可能存在一些由于噪声和颜色变化引起的一些伪边缘存在
    # 人为设置一个高阈值一个低阈值，保留高于高阈值的边缘像素，抑制低于低阈值的边缘像素
    # 如果边缘像素的值高于高阈值，将其标记为强边缘像素；
    # 如果边缘像素值小于高阈值但大于低阈值，则将其标记为弱边缘像素；
    # 如果边缘像素值小于低阈值，则会被抑制
    # 5.进一步确认弱边缘像素的去留
    # 再通过弱边缘像素是否和强边缘相连这条规则，确定是要保留这个弱边缘像素还是抛弃这个边缘像素
    # 如果弱边缘是和强边缘连接的，那么会保留；如果是由于噪声产生的弱边缘，那么基本不太可能和强边缘连接，就抛弃

    # 数值设置越大，门槛越高，边缘检测的纹理信息越少
    # 数值设置越小，门槛越低，边缘检测的纹理信息越多
    cv.Canny(image=img, threshold1=80, threshold2=150)

